/*
 * Copyright 2023 Responsive Computing, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.responsive.kafka.internal.metrics;

import com.datastax.oss.driver.api.core.context.DriverContext;
import com.datastax.oss.driver.api.core.metadata.Node;
import com.datastax.oss.driver.api.core.metrics.DefaultSessionMetric;
import com.datastax.oss.driver.api.core.metrics.Metrics;
import com.datastax.oss.driver.api.core.metrics.SessionMetric;
import com.datastax.oss.driver.internal.core.context.InternalDriverContext;
import com.datastax.oss.driver.internal.core.metrics.MetricsFactory;
import com.datastax.oss.driver.internal.core.metrics.NodeMetricUpdater;
import com.datastax.oss.driver.internal.core.metrics.NoopNodeMetricUpdater;
import com.datastax.oss.driver.internal.core.metrics.NoopSessionMetricUpdater;
import com.datastax.oss.driver.internal.core.metrics.SessionMetricUpdater;
import edu.umd.cs.findbugs.annotations.Nullable;
import java.util.Collections;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import org.apache.kafka.common.MetricName;
import org.apache.kafka.common.metrics.Sensor;
import org.apache.kafka.common.metrics.stats.CumulativeCount;
import org.apache.kafka.common.metrics.stats.CumulativeSum;

/**
 * This class adapts the metrics generated by the Cassandra client to be exported through Kafka metrics.
 * <p>
 * See <a href="https://docs.datastax.com/en/developer/java-driver/4.15/manual/core/metrics/index.html">here</a>
 * for a description of metrics usage in the Cassandra driver.
 * </p>
 * <p>
 * For a description of each metric exposed by the driver see the
 * <a href="https://docs.datastax.com/en/developer/java-driver/4.15/manual/core/configuration/reference/index.html">reference documentation</a>.
 * </p>
 */
public class CassandraMetricsFactory implements MetricsFactory {
  static final String CASSANDRA_METRICS_GROUP = "cassandra-driver";
  private final SessionMetricUpdater sessionMetricUpdater;

  public CassandraMetricsFactory(final DriverContext driverContext) {
    this.sessionMetricUpdater = fetchMetrics(driverContext)
        .map(metrics -> (SessionMetricUpdater)new CassandraMetricUpdater(metrics))
        .orElse(NoopSessionMetricUpdater.INSTANCE);
  }

  private static Optional<ResponsiveMetrics> fetchMetrics(DriverContext driverContext) {
    // Note that there seems to be no alternative to accessing the metric registry
    // than `InternalDriverContext`. Each of the included metric factory classes
    // cast in order to get access.
    if (driverContext instanceof InternalDriverContext) {
      final InternalDriverContext internalDriverContext = (InternalDriverContext) driverContext;
      final Object metricRegistry = internalDriverContext.getMetricRegistry();
      if (metricRegistry instanceof ResponsiveMetrics) {
        return Optional.of((ResponsiveMetrics) internalDriverContext.getMetricRegistry());
      }
    }
    return Optional.empty();
  }

  @Override
  public Optional<Metrics> getMetrics() {
    return Optional.empty();
  }

  @Override
  public SessionMetricUpdater getSessionUpdater() {
    return sessionMetricUpdater;
  }

  @Override
  public NodeMetricUpdater newNodeUpdater(final Node node) {
    return NoopNodeMetricUpdater.INSTANCE;
  }

  private static class CassandraMetricUpdater implements SessionMetricUpdater {
    private final ResponsiveMetrics metrics;

    private CassandraMetricUpdater(final ResponsiveMetrics metrics) {
      this.metrics = metrics;
    }

    @Override
    public void incrementCounter(
        final SessionMetric sessionMetric,
        @Nullable final String profileName,
        final long amount
    ) {
      getOrCreateSensor(sessionMetric).record(amount);
    }

    @Override
    public void updateHistogram(
        final SessionMetric sessionMetric,
        @Nullable final String s,
        final long value
    ) {
      getOrCreateSensor(sessionMetric).record(value);
    }

    @Override
    public void markMeter(
        final SessionMetric sessionMetric,
        @Nullable final String profileName,
        final long amount
    ) {
      getOrCreateSensor(sessionMetric).record(amount);
    }

    @Override
    public void updateTimer(
        final SessionMetric sessionMetric,
        @Nullable final String profileName,
        final long duration,
        final TimeUnit timeUnit
    ) {
      getOrCreateSensor(sessionMetric)
          .record(TimeUnit.MILLISECONDS.convert(duration, timeUnit));
    }

    @Override
    public boolean isEnabled(
        final SessionMetric metric,
        @Nullable final String profileName
    ) {
      switch (asDefaultSessionMetric(metric)) {
        case BYTES_SENT:
        case BYTES_RECEIVED:
        case CQL_REQUESTS:
        case CQL_CLIENT_TIMEOUTS:
        case THROTTLING_DELAY:
        case THROTTLING_ERRORS:
          return true;
        default:
          return false;
      }
    }

    private String sensorName(SessionMetric metric) {
      return "cassandra-" + metric.getPath();
    }

    private DefaultSessionMetric asDefaultSessionMetric(SessionMetric metric) {
      if (metric instanceof DefaultSessionMetric) {
        return (DefaultSessionMetric) metric;
      } else {
        return DefaultSessionMetric.fromPath(metric.getPath());
      }
    }

    Sensor getOrCreateSensor(SessionMetric metric) {
      final DefaultSessionMetric sessionMetric  = asDefaultSessionMetric(metric);
      final String sensorName = sensorName(sessionMetric);

      Sensor sensor = metrics.getSensor(sensorName);
      if (sensor == null) {
        sensor = metrics.addSensor(sensorName);

        switch (sessionMetric) {
          case BYTES_SENT:
            // Exposed as a Meter
            sensor.add(new MetricName(
                "bytes-sent",
                CASSANDRA_METRICS_GROUP,
                "Cumulative bytes sent",
                Collections.emptyMap()
            ), new CumulativeSum());
            break;

          case BYTES_RECEIVED:
            // Exposed as a Meter
            sensor.add(new MetricName(
                "bytes-received",
                CASSANDRA_METRICS_GROUP,
                "Cumulative bytes received",
                Collections.emptyMap()
            ), new CumulativeSum());
            break;

          case CQL_REQUESTS:
            // Exposed as a Timer
            sensor.add(new MetricName(
                "cql-requests-count",
                CASSANDRA_METRICS_GROUP,
                "Cumulative CQL request count",
                Collections.emptyMap()
            ), new CumulativeCount());
            sensor.add(new MetricName(
                "cql-requests-cumulative-latency",
                CASSANDRA_METRICS_GROUP,
                "Cumulative CQL request latency in milliseconds",
                Collections.emptyMap()
            ), new CumulativeSum());
            break;

          case CQL_CLIENT_TIMEOUTS:
            // Exposed as a Counter
            sensor.add(new MetricName(
                "cql-request-timeouts-count",
                CASSANDRA_METRICS_GROUP,
                "Cumulative count of CQL request timeouts",
                Collections.emptyMap()
            ), new CumulativeSum());
            break;

          case THROTTLING_DELAY:
            // Exposed as a Timer
            sensor.add(new MetricName(
                "throttling-cumulative-delay",
                CASSANDRA_METRICS_GROUP,
                "Cumulative throttling delay in milliseconds",
                Collections.emptyMap()
            ), new CumulativeSum());
            break;

          case THROTTLING_ERRORS:
            // Exposed as a Counter
            sensor.add(new MetricName(
                "throttling-errors-count",
                CASSANDRA_METRICS_GROUP,
                "Cumulative count of throttling errors",
                Collections.emptyMap()
            ), new CumulativeSum());
            break;

          case CONNECTED_NODES:
          case THROTTLING_QUEUE_SIZE:
          case CQL_PREPARED_CACHE_SIZE:
            break;
        }
      }
      return sensor;
    }
  }

}
